{"version":3,"file":"app.fb9370e5799434af09ba.hot-update.js","mappings":";;;;;;;;;;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAKA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;;AAOA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAGA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA","sources":["webpack://@roots/bud/sage/sage/./scripts/layout/blob.js"],"sourcesContent":["let canvas, ctx;\nlet render, init;\nlet blob;\n\nclass Blob {\n    constructor() {\n        this.points = [];\n    }\n\n    init() {\n        for (let i = 0; i < this.numPoints; i++) {\n            let point = new Point(this.divisional * (i + 1), this);\n            this.push(point);\n        }\n    }\n\n    render() {\n        let canvas = this.canvas;\n        let ctx = this.ctx;\n        let position = this.position;\n        let pointsArray = this.points;\n        let radius = this.radius;\n        let points = this.numPoints;\n        let divisional = this.divisional;\n        let center = this.center;\n\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n        pointsArray[0].solveWith(pointsArray[points - 1], pointsArray[1]);\n\n        let p0 = pointsArray[points - 1].position;\n        let p1 = pointsArray[0].position;\n        let _p2 = p1;\n\n        ctx.beginPath();\n        ctx.moveTo(center.x, center.y);\n        ctx.moveTo((p0.x + p1.x) / 2, (p0.y + p1.y) / 2);\n\n        for (let i = 1; i < points; i++) {\n            pointsArray[i].solveWith(\n                pointsArray[i - 1],\n                pointsArray[i + 1] || pointsArray[0]\n            );\n\n            let p2 = pointsArray[i].position;\n            var xc = (p1.x + p2.x) / 2;\n            var yc = (p1.y + p2.y) / 2;\n            ctx.quadraticCurveTo(p1.x, p1.y, xc, yc);\n\n            p1 = p2;\n        }\n\n        var xc = (p1.x + _p2.x) / 2;\n        var yc = (p1.y + _p2.y) / 2;\n        ctx.quadraticCurveTo(p1.x, p1.y, xc, yc);\n\n        ctx.closePath();\n\n        // Create a linear gradient\n        const gradient = ctx.createLinearGradient(\n            center.x - radius,\n            center.y,\n            center.x + radius,\n            center.y\n        );\n\n        // Add color stops to the gradient\n        gradient.addColorStop(0, \"#e2b8f6\"); // Start color\n        gradient.addColorStop(1, \"#7759d2\"); // End color\n\n        // Set the gradient as the fill style\n        ctx.fillStyle = gradient;\n\n        // Fill the blob with the gradient color\n        ctx.fill();\n\n        requestAnimationFrame(this.render.bind(this));\n    }\n\n    push(item) {\n        if (item instanceof Point) {\n            this.points.push(item);\n        }\n    }\n\n    set color(value) {\n        this._color = value;\n    }\n    get color() {\n        return this._color || \"#0091DA\";\n    }\n\n    set canvas(value) {\n        if (\n            value instanceof HTMLElement &&\n            value.tagName.toLowerCase() === \"canvas\"\n        ) {\n            this._canvas = value;\n            this.ctx = this._canvas.getContext(\"2d\");\n        }\n    }\n    get canvas() {\n        return this._canvas;\n    }\n\n    set numPoints(value) {\n        if (value > 2) {\n            this._points = value;\n        }\n    }\n    get numPoints() {\n        return this._points || 32;\n    }\n\n    set radius(value) {\n        if (value > 0) {\n            this._radius = value;\n        }\n    }\n    get radius() {\n        return this._radius || 580;\n    }\n\n    set position(value) {\n        if (typeof value == \"object\" && value.x && value.y) {\n            this._position = value;\n        }\n    }\n    get position() {\n        return this._position || { x: 0.15, y: 0.25 };\n    }\n\n    get divisional() {\n        return (Math.PI * 2) / this.numPoints;\n    }\n\n    get center() {\n        return {\n            x: this.canvas.width * this.position.x,\n            y: this.canvas.height * this.position.y,\n        };\n    }\n\n    set running(value) {\n        this._running = value === true;\n    }\n    get running() {\n        return this.running !== false;\n    }\n}\n\nclass Point {\n    constructor(azimuth, parent) {\n        this.parent = parent;\n        this.azimuth = Math.PI - azimuth;\n        this._components = {\n            x: Math.cos(this.azimuth),\n            y: Math.sin(this.azimuth),\n        };\n\n        this.acceleration = -0.3 + Math.random() * 0.6;\n    }\n\n    solveWith(leftPoint, rightPoint) {\n        this.acceleration =\n            (-0.3 * this.radialEffect +\n                (leftPoint.radialEffect - this.radialEffect) +\n                (rightPoint.radialEffect - this.radialEffect)) *\n                this.elasticity -\n            this.speed * this.friction;\n    }\n\n    set acceleration(value) {\n        if (typeof value == \"number\") {\n            this._acceleration = value;\n            this.speed += this._acceleration * 2;\n        }\n    }\n    get acceleration() {\n        return this._acceleration || 0;\n    }\n\n    set speed(value) {\n        if (typeof value == \"number\") {\n            this._speed = value;\n            this.radialEffect += this._speed * 5;\n        }\n    }\n    get speed() {\n        return this._speed || 0;\n    }\n\n    set radialEffect(value) {\n        if (typeof value == \"number\") {\n            this._radialEffect = value;\n        }\n    }\n    get radialEffect() {\n        return this._radialEffect || 0;\n    }\n\n    get position() {\n        return {\n            x:\n                this.parent.center.x +\n                this.components.x * (this.parent.radius + this.radialEffect),\n            y:\n                this.parent.center.y +\n                this.components.y * (this.parent.radius + this.radialEffect),\n        };\n    }\n\n    get components() {\n        return this._components;\n    }\n\n    set elasticity(value) {\n        if (typeof value === \"number\") {\n            this._elasticity = value;\n        }\n    }\n    get elasticity() {\n        return this._elasticity || 0.001;\n    }\n    set friction(value) {\n        if (typeof value === \"number\") {\n            this._friction = value;\n        }\n    }\n    get friction() {\n        return this._friction || 0.0085;\n    }\n}\n\nblob = new Blob();\nblob.position = { x: 0.55, y: 0.25 }; // Move the blob to the right side\n\ninit = function () {\n    const blobContainer = document.querySelector(\".blob\");\n\n    canvas = document.createElement(\"canvas\");\n    canvas.setAttribute(\"touch-action\", \"none\");\n\n    blobContainer.appendChild(canvas);\n\n    let resize = function () {\n        canvas.width = blobContainer.offsetWidth;\n        canvas.height = blobContainer.offsetHeight;\n    };\n    window.addEventListener(\"resize\", resize);\n    resize();\n\n    let oldMousePoint = { x: 0, y: 0 };\n    let hover = false;\n    let mouseMove = function (e) {\n        let pos = blob.center;\n        let diff = { x: e.clientX - pos.x, y: e.clientY - pos.y };\n        let dist = Math.sqrt(diff.x * diff.x + diff.y * diff.y);\n        let angle = null;\n\n        blob.mousePos = { x: pos.x - e.clientX, y: pos.y - e.clientY };\n\n        if (dist < blob.radius && hover === false) {\n            let vector = { x: e.clientX - pos.x, y: e.clientY - pos.y };\n            angle = Math.atan2(vector.y, vector.x);\n            hover = true;\n        } else if (dist > blob.radius && hover === true) {\n            let vector = { x: e.clientX - pos.x, y: e.clientY - pos.y };\n            angle = Math.atan2(vector.y, vector.x);\n            hover = false;\n            blob.color = null;\n        }\n\n        if (typeof angle == \"number\") {\n            let nearestPoint = null;\n            let distanceFromPoint = 100;\n\n            blob.points.forEach((point) => {\n                if (Math.abs(angle - point.azimuth) < distanceFromPoint) {\n                    nearestPoint = point;\n                    distanceFromPoint = Math.abs(angle - point.azimuth);\n                }\n            });\n\n            if (nearestPoint) {\n                let strength = {\n                    x: oldMousePoint.x - e.clientX,\n                    y: oldMousePoint.y - e.clientY,\n                };\n                strength =\n                    Math.sqrt(\n                        strength.x * strength.x + strength.y * strength.y\n                    ) * 10;\n                if (strength > 100) strength = 100;\n                nearestPoint.acceleration = (strength / 100) * (hover ? -1 : 1);\n            }\n        }\n\n        oldMousePoint.x = e.clientX;\n        oldMousePoint.y = e.clientY;\n    };\n    window.addEventListener(\"pointermove\", mouseMove);\n\n    blob.canvas = canvas;\n    blob.init();\n    blob.render();\n};\n\ninit();\n"],"names":[],"sourceRoot":""}